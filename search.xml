<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>字节前端青训营：shell脚本与编程</title>
      <link href="/2023/04/19/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/04/19/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="shell脚本编程">shell脚本编程</h2><h4 id="一-shell基本概念">一.shell基本概念</h4><p><strong>1.概念</strong>：</p><p>终端：获取用户输入，展现运算结果的硬件设备</p><p>tty: teletypewriter的简称，和终端等价，早期指电传印机，在Linux中是输入输出环境</p><p>终端模拟器：Mac terminal,iTerm2等，关联虚拟tty的输入输出软件</p><p>shell：command interpreter 处理来自终端模拟器的输入，解释执行之后输出结果给终端</p><p>bash: shell的具体实现</p><p>物理终端=&gt;软件终端=&gt;终端模拟器=&gt;shell<br>tty或者说终端最开始指的是获取用户输入并输出的物理设备，比如电传打字机，在Linux中是接收用户输入，输出结果的终端仿真软件，比如我们用的mac terminal，iterm2等，更强输入辅助功能，画面绘制输出的终端模拟器，而tty变成一个虚拟概念，是Linux的一个程序，每个终端模拟器关联一个虚拟tty，和内核打交道，我们可以在终端模拟器中输入tty查看关联到的虚拟tty，bash是shell的一种具体实现，可以理解成实例和类的关系</p><p><strong>2.概念</strong>：</p><p>shell不仅提供了与内核和设备交互的方法，还集成了一些今天软件开发中通用语的设计模式（比如管道和过滤器），具备控制流程，循环，变量，命令查找的机制，既是命令解释器，也是一门编程语言，作为命令解释器，他提供给用户接口，使用丰富的GNU工具集，第三方的或者内置的，比如cd,pwd,exec,test,netstat等等</p><p><img src="/shell%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%BC%96%E7%A8%8B/shell%E6%9E%84%E6%88%90.png" alt="image"></p><h3 id="二-语法与命令">二.语法与命令</h3><p><strong>1.变量</strong>：</p><p><img src="/shell%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%BC%96%E7%A8%8B/shell%E5%8F%98%E9%87%8F.png" alt="image"></p><p><strong>2.自定义变量</strong>：</p><p>-p显示变量及其被声明的类型</p><p><img src="/shell%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%BC%96%E7%A8%8B/shell%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F.png" alt="image"></p><p><strong>3.系统环境变量</strong>：</p><p>bash shell在启动时总要配置其运行环境，例如初始化环境变量，设置命令提示符，指定系统命令路径等</p><p><img src="/shell%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%BC%96%E7%A8%8B/shell%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="image"></p><p><strong>4.配置环境加载</strong>：</p><p>如果取得bash需要完整的登陆流程，我们称之为login shell,比如ssh远程登录一台主机<br>不需要登陆的bash我们称之为non-login bash，比如在原来的bash中执行bash开启子进程，执行一些外部命令<br>如果修改了配置文件， 不会立即生效，需要我们重启终端或者执行source命令</p><p><img src="/shell%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%BC%96%E7%A8%8B/shell%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8A%A0%E8%BD%BD.png" alt="image"></p><p><strong>5.运算符和引用</strong>：</p><p>双引号：部分引用，使用这种引用时，$,`(反引号)，（转义符）这3 个还是会解析成特殊的意义<br>单引号：完全引用，只原样输出<br>反引号：执行命令<br>cmd &amp;实现让命令在后台运行<br>使用方法一时，当我们关闭终端，命令就会停止运行，加上nohup可以在关闭终端后不停止命令</p><p><img src="/shell%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%BC%96%E7%A8%8B/shell%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%BC%95%E7%94%A8.png" alt="image"></p><p><strong>6.管道</strong>：</p><p>如果需要互通，比如第一个命令的返回传递给第二个命令，就需要用到管道了，管道的本质是将多个程序进行了一个连接，和信号一样，也是进程通信的方式之一</p><p>管道和管道运算符 | ，作用是将前一个命令的结果传递给后面的命令</p><p>语法：cmd1 | cmd2</p><p>要求：管道右侧的命令必须能接受标准输入才行，比如grep命令，Is,mv等不能直接使用，可以使用xargs预处理</p><p>注意：管道命令仅仅处理stdout，对于stderr会予以忽略，可以使用set -o pipefail设置shell遇到管道错误退出</p><p><img src="/shell%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%BC%96%E7%A8%8B/shell%E7%AE%A1%E9%81%93.png" alt="image"></p><p><strong>7.重定向</strong>：</p><p>输出重定向符号</p><p>‘&gt;’ :覆盖写入文件</p><p>‘&gt;&gt;’ :追加写入文件</p><p>2&gt;:错误输出写入文件</p><p>&amp;&gt;:正确和错误输出同意写入</p><p>输入重定向符号： &lt; &lt;&lt;</p><p>每个shell命令在执行时都会打开三个文件描述符，文件描述符0，1，2，分别对应stdin,stdout,stderr,这桑文件描述符默认指向终端输入，终端输出，那么当命令需要获取输入的时候，他会去读取fd0,当要输出的时候它会像fd1,fd2写入，改变这些描述符指向的行为叫做重定向</p><p>&lt;&lt;比较特殊，表示继续沿用当前的标准输入，只是当识别到指定的标识符后停止，将接收到的内容作为stdin</p><p><img src="/shell%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%BC%96%E7%A8%8B/shell%E9%87%8D%E5%AE%9A%E5%90%91.png" alt="image"></p><p><strong>8.判断命令</strong>：</p><p>shell中提供了test,[,[[，三种判断符号，可用于整数测试，字符串测试，文件测试</p><p>语法：test condition  [ condition ]  [[ condition ]]</p><p>注意：</p><p>中括号前后要有空格符</p><p>[  和test是命令，只能用自己支持的标志位，&lt;,&gt;,=只能用来比较字符串</p><p>中括号内的变量最好都是用引号括起来</p><p>[[更丰富，在整型比较中支持&lt;,&gt;,=，在字符串比较中支持=~正则</p><p><img src="/shell%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%BC%96%E7%A8%8B/shell%E5%88%A4%E6%96%AD%E5%91%BD%E4%BB%A4.png" alt="image"></p><p><strong>9.分支语句</strong>：</p><p>语法一：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition ; then</span><br><span class="line">程序段</span><br><span class="line">elif condition ; then</span><br><span class="line">程序段</span><br><span class="line">esle</span><br><span class="line">程序段</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>语法二：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case $变量 in:</span><br><span class="line">&quot;第一个变量内容&quot;)</span><br><span class="line">程序段</span><br><span class="line">;;</span><br><span class="line">&quot;第一个变量内容&quot;)</span><br><span class="line">程序段</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">程序段</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p><strong>10.循环</strong>：</p><p>while循环：<code> while condition ; do 程序段 ; done</code></p><p>until循环 (util条件成立时会立即推出循环)：<code>until condition ; do 程序段 ; done</code></p><p>for循环 ：<code>for var in [words...] ; do 程序段  ; done</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">let num=0</span><br><span class="line">until [ $num -gt 10] ;</span><br><span class="line">do</span><br><span class="line">echo &quot;current idx : $num&quot;</span><br><span class="line">((num++))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>11.函数</strong>：</p><p>函数也是命令<br>为了函数内定义的变量不污染全局，最好用local定义，或者在函数退出之前使用unset处理一下</p><p>语法一：<code>funcName () &#123;echo &quot;abc&quot;;&#125;</code></p><p>语法二：<code>function funcName() &#123;echo &quot;abc&quot;;&#125;</code></p><p>注意：</p><p>shell自上而下执行，函数必须在使用前定义</p><p>函数获取变量和shell script类似，$0代表函数名，后续参数通过$1,$2…获取</p><p>函数内return仅仅表示函数执行状态，不代表函数执行结果</p><p>返回结果一般使用echo,printf在外面使用$(),``来获取结果</p><p>如果没有return，函数状态是上一条命令的执行状态，储存在$?中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">printname()</span><br><span class="line">&#123;</span><br><span class="line">if [ $# -lt 2] ; then</span><br><span class="line">echo &quot;illegal parameter.&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;firstname is : $1&quot;</span><br><span class="line">echo &quot;lastname id :$2&quot;</span><br><span class="line">&#125;</span><br><span class="line">printname jacky chen</span><br></pre></td></tr></table></figure><p><strong>12.模块化</strong>：</p><p>模块化的原理是在当前shell内执行函数文件，方式：</p><p>source [函数库的路径]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">add函数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">@<span class="built_in">return</span> paltForm</span></span><br><span class="line">function add()&#123;</span><br><span class="line">declare -i res=$1+$@</span><br><span class="line">echo $res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line">source &#x27;./math.sh&#x27;</span><br><span class="line">total=$(add 1 2)</span><br><span class="line">echo $total</span><br></pre></td></tr></table></figure><p><strong>14,常用命令</strong>：</p><p><img src="/shell%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%BC%96%E7%A8%8B/shell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.png" alt="image"></p><h3 id="三-执行过程和原理">三.执行过程和原理</h3><p><strong>1.执行:</strong></p><p>1.shell脚本一般以.sh结尾也可以没有，这是一个约定，第一行需要指定用什么命令解释器来执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/new bash</span></span><br></pre></td></tr></table></figure><p>2.启动方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件名运行</span></span><br><span class="line">./filename.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解释器运行</span></span><br><span class="line">bash ./filename.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">source</span>运行</span></span><br><span class="line">source ./filename.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#! 是内核识别并选择合适的解释器之后，将文本文件再交给解释器执行</p><p><strong>3.执行过程</strong><br>1.字符解析</p><ul><li>识别换行符，分号做行的分割</li><li>识别命令连接符（|| &amp;&amp; 管道）做命令的分割</li><li>识别空格，tab符，做命令和参数的分割</li></ul><p>2.shell展开，例如｛1…3}解析为1 2 3<br>3.重定向，将stdin,stdout,stderr的文件描述符进行指向变更<br>4.执行命令</p><ul><li>builtin直接执行</li><li>非builtin使用$path查找，然后启动子程序进行</li></ul><p>5.收集状态并返回</p><p><img src="/shell%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%BC%96%E7%A8%8B/shell%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="image"><br>这个架构类似一个流水线，在里面进行输入分析和解析<br>bash会以一些特殊字符作为分隔符，将文本进行分段解析，最主要是回车还有分号，在bash脚本中是以回车</p><p><strong>4.shell展开</strong>：</p><p>大括号展开 brace expansion {…}</p><p>一般由三部分组成，前缀，一对大括号，后缀，大括号内可以是逗号分隔的字符串序列，也可以是序列表达式{x…y[…incr]}</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">字符串序列</span></span><br><span class="line">a&#123;b,c,d&#125;e =&gt; abe ace ade</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">表达式序列 数字可以使用incr调整增量，字母不行</span></span><br><span class="line">&#123;1...5&#125; -&gt; 1 2 3 4 5</span><br><span class="line">&#123;1..5..2&#125; -&gt; 1 3 5</span><br><span class="line">&#123;a..e&#125; -&gt; a b c d e</span><br></pre></td></tr></table></figure><p>波浪号展开 tilde expansion ~</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当前用户主目录</span></span><br><span class="line">~  -&gt;  $HOME</span><br><span class="line">-/foo  -&gt; $HOME/foo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定用户的主目录</span></span><br><span class="line">-fred/foo  -&gt; 用户fred的$HOME/foo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当前工作目录</span></span><br><span class="line">-+/foo  -&gt;  $PWD/foo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上一个工作目录</span></span><br><span class="line">--/foo  -&gt;  $($OLDPWD-&#x27;--&#x27;)/foo</span><br></pre></td></tr></table></figure><p>参数展开 shell parameter expansion  ${ }</p><p>1.间接参数扩展 ${!parameter},其中引用的参数并不是parameter而是parameter实际的值</p><p>2.参数长度 $</p>]]></content>
      
      
      <categories>
          
          <category> 字节前端训练营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> shell脚本与编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节前端青训营：Linux基础</title>
      <link href="/2023/04/15/Linux%E5%9F%BA%E7%A1%80%EF%BC%88%E9%9D%92%E8%AE%AD%EF%BC%89/"/>
      <url>/2023/04/15/Linux%E5%9F%BA%E7%A1%80%EF%BC%88%E9%9D%92%E8%AE%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一-计算机硬件">一.计算机硬件</h3><p><strong>计算机由五大基本单元组成：控制器，运算器，存储器，输入输出两个单元</strong></p><p><strong>1.控制器</strong>:协调和指挥计算机各个部件进行按需作业</p><p><strong>2.运算器</strong>:算数与逻辑运算的处理</p><p><strong>3.存储器</strong>:内存和外存，磁盘光驱属于外存</p><p><strong>4.输入单元</strong>:鼠标，键盘等</p><p><strong>5.输出单元</strong>:显示器，音响等</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/%E4%BA%94%E5%A4%A7%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png" alt="图片"></p><h3 id="二-计算机操作系统">二.计算机操作系统</h3><p>1.<strong>操作系统</strong>（<strong>O</strong>perating <strong>S</strong>ystem，<strong>OS</strong>）：管理和控制计算机系统中的硬件和软件资源，用于在用户和系统硬件之间传递消息</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/image.png" alt="图片"></p><p>**2.操作系统启动程序：**操作系统的启动分为传统模式，也就是基于bios的启动流程，另一种是当前的主流模式，也就是基于UEFI的启动流程。BIOS或者UEFI其实就是一段固化在主板上的程序，计算机启动时会默认运行这段程序，然后通过这段程序去运行主板引导项，UEFI是BIOS流程的升级版本，解决优化了BIOS启ootloader也就是操作系统引导程序，然后通过引导初始化操作系统。比如优化了BIOS自检流程，然后BIOS启动会配合MBR分区，无法引导启动超过2.2T的磁盘。而UEFI一般配合GPT分区，支持引导超过2.2T的磁盘。</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/1.png" alt="图片"></p><h3 id="三-Linux系统概览">三.Linux系统概览</h3><p>**1.Linux版本：**内核版本+发行版本，其中Linux内核加常用软件为Linux发行版本。</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/2.png" alt="图片"></p><p><strong>2.查看Linux系统内核版本：</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/3.png" alt="图片"></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/4.png" alt="图片"></p><p><strong>3.Linux系统应用领域：</strong></p><p>IT服务器（操作系统，虚拟化和云计算)，嵌入式和智能设备，个人办公桌面，学术研究和软件开发</p><h3 id="四-Linux系统结构">四.Linux系统结构</h3><p>**1.四个组成部分：**内核，shell，文件系统，应用程序</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/5.png" alt="图片"></p><h4 id="4-2-Linux系统结构–进程管理">4.2.Linux系统结构–进程管理</h4><p>**2.Linux体系结构：**内核是硬件和软件的一个中间层，是一个资源管理系统，提供一组面向系统的命令</p><p>体系结构子目录都包含许多其他子目录，这些子目录专注于内核的特定方面，如引导，内核，内存管理等</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/6.png" alt="图片"></p><p><strong>3.进程管理</strong></p><p>1.进程：是一个正在执行的一个程序或者命令，有自己的地址空间，占用一定的系统资源。一个CPU核同一时间只能运行一个进程，进程由它的进程ID（PID）和它父进程的进程ID（PPID）唯一识别</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/7.png" alt="图片"></p><p><strong>2.查看进程信息：</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/8.png" alt="图片"></p><p>**3.进程调度：**进程调度是指操作系统按某种策略或者规则选择进程占用CPU进行运行的过程</p><ul><li><p>R(TASK_RUNNING) 可执行状态</p></li><li><p>S(TASK_INTERRUPTIBLE) 可中断的睡眠状态</p></li><li><p>D(TASK_UNINTERRUPTIBLE) 不可中断的睡眠状态</p></li><li><p>T(TASK_STOPPED OR TASK_TRACED) 暂停或者跟踪状态</p></li><li><p>Z(TASK_DEAD-EXIT_ZOMBIE) 退出状态，进程变为僵尸进程</p></li><li><p>X(TASK_DEAD-EXIT_DEAD) 退出状态，进程即将被销毁</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/9.png" alt="图片"></p></li></ul><p><strong>4.进程调度原则</strong></p><ul><li>一个CPU核同一时间只能运行一个进程</li><li>每个进程有近乎相等的执行时间</li><li>对于逻辑CPU而言进程调度使用轮询的方式执行，当轮询完成则回到第一个进程反复</li><li>进程执行消耗时间和进程量成正比</li></ul><p><strong>5.进程的系统调用</strong></p><p>内核空间（Kernal Space):系统内核运行的空间</p><p>用户空间（User Space):应用程序运行的空间</p><p>当进程运行在内核空间时就处于内核态，二进程运行在用户空间时则处于用户态</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/10.png" alt="图片"></p><h4 id="4-3Linux系统结构–文件系统">4.3Linux系统结构–文件系统</h4><p><strong>1.文件系统</strong>：文件系统负责管理持久化数据的子系统，负责把用户的文件存到磁盘硬件中，这样做最明显的好处是开发者仅需要一套API和开发工具即可调取Linux系统中绝大部分的资源。举个例子来说，Linux中几乎所有读（读文件，读系统状态读socket，读PIPE）的操作都可以用read函数来进行，几乎所有更改（更改文件，更改系统参数，写socket，写PIPE）的操作都可以用write函数来进行，使用任何硬件设备都必须与根目录下某一目录执行挂载操作</p><p><strong>2.存储</strong>：Linux文件系统是采用树状的目录结构，最上层是/（根）目录</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/11.png" alt="图片"></p><p><strong>/bin:</strong>  bin是Binaries(二进制文件)的缩写，这个目录存放着最经常使用的命令</p><p><strong>/boot:</strong>  这里存放的是启动Linux时使用的一些核心文件，包括一些链接文件以及镜像文件</p><p>**/dev: ** dev是Device（设备）的缩写，该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的</p><p>**/etc：**etc是Etcetera(等等)的缩写，这个目录用来存放所有的系统管理所需要的配置文件和子目录</p><p><strong>/home:</strong> 用户的主目录，在Linux中每个用户都有自己的一个目录，一般该目录名是以用户的账号命名的</p><p><strong>/lib:</strong>  lib是Library（库）的缩写，这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件，几乎所有的应用程序都需要用到这些共享库</p><p><strong>/mnt:</strong>  系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里面的内容了</p><p><strong>/opt:</strong> opt是optional（可选）的缩写，这是给主机额外安装软件所摆放的目录，比如你安装一个ORACLE数据库则可以放在这个目录下，默认是空的</p><p><strong>/proc:</strong> proc是processes（进程）的缩写，/proc是一种伪系统文件（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息</p><p><strong>/root:</strong> 该目录为系统管理员，也称作超级权限者的用户主目录</p><p><strong>/sbin:</strong> s是super user的意思，是Superuser Binaries(超级用户的二进制文件)的缩写，这里存放的是系统管理员使用的系统管理程序</p><p><strong>/usr:</strong> usr是unix shared resources（共享资源）的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于Windows下的program files目录</p><p><strong>3.虚拟文件系统（VFS）</strong>：</p><ul><li>对应用层提供一个标准的文件操作接口</li><li>对文件系统提供一个标准的文件接入接口</li></ul><p>虚拟系统文件系统使得Linux可以存在多个“实际的文件系统”，比如分区是1是ext2，分区2是ext3，分区3是fat32，那么每个“实际的文件系统”的结构和操作方式是不一样的。VFS作为中间层，用户直接控制VFS，VFS再控制各个文件系统</p><p><strong>4.查看文件系统类型</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/12.png" alt="图片"></p><p><strong>5.文件基本操作</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/13.png" alt="图片"></p><p><strong>6.文件读取流程</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/14.png" alt="图片"></p><h4 id="4-4Linux系统结构–用户权限">4.4Linux系统结构–用户权限</h4><p><strong>1.用户账户</strong>：Linux是一个多用户的系统，可以多个用户登陆Linux</p><ul><li><p>用户账户</p><p>普通用户账户：在系统中进行普通作业</p><p>超级用户账户：在系统中对普通用户和整个系统进行管理</p></li><li><p>用户组</p><p>标准组：可以容纳多个用户</p><p>私有组：只有用户自己</p></li></ul><p><strong>2.文件权限：</strong></p><p>文件权限关于用户有三个概念：</p><p>所有组：文件的所有者</p><p>所在组：文件的所有者所在的组</p><p>其他人：除文件所有者及所在组外的其他人</p><p>每个用户对于文件都有不同权限，读R，写W，执行X</p><p><strong>3.查看用户信息</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/15.png" alt="图片"></p><p><strong>4.用户权限操作</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/16.png" alt="图片"></p><h3 id="五-Linux软件包操作">五.Linux软件包操作</h3><p><strong>1.软件包</strong>：</p><ul><li><p>软件包：通常指的是一个应用程序，他可以是一个GUI应用程序，命令行工具或者（其他软件程序需要的）软件库</p></li><li><p>软件包管理：</p><p>底层工具：主要用来处理安装和删除软件包文件等任务，DPKG，RPM</p><p>上层工具：主要用于数据的搜索任务和依赖解析任务，APT，YUM，DNF</p><p>YUM可以自动下载并安装所有需要的依赖项，但是RPM会告诉你安装一个依赖列表，然后你必须手动安装</p></li></ul><p><strong>2.软件包安装工具：</strong></p><p>RPM（Red Hat Package Manager),为Red Hat操作系统的包管理系统</p><p>DPKG（Debian package），为Debian操作系统的包管理系统</p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/17.png" alt="图片"></p><p><strong>3.Debian Apt常用命令：</strong></p><ul><li>列出所有可更新的软件清单命令：apt update</li><li>安装指定的软件命令：apt install&lt;package_name&gt;</li><li>安装多个软件包： apt install &lt;package_1&gt; &lt;package_2&gt; &lt;package_3&gt;</li><li>更新指定的软件命令：apt update &lt;package_name&gt;</li><li>删除软件包命令：apt remove &lt;package_name&gt;</li><li>查找软件包命令：apt search &lt;key_word&gt;</li><li>列出所有已安装的包：apt list --installed</li></ul><p><strong>4.nginx安装</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/18.png" alt="图片"></p><p><strong>5.nginx配置</strong></p><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/19.png" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> 字节前端训练营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> linux基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
